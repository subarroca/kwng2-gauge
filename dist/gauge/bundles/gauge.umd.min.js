!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?t(exports,require("@angular/core"),require("@angular/common")):"function"==typeof define&&define.amd?define("gauge",["exports","@angular/core","@angular/common"],t):t(e.gauge={},e.ng.core,e.ng.common)}(this,function(e,t,n){"use strict";var r=function(){function e(e){void 0===e&&(e={}),this.radius=e.radius||100,this.goal=e.goal||100,this.value=e.value,this.color=e.color,this.bgColor=e.bgColor||"transparent",this.borderWidth=e.borderWidth||100}return Object.defineProperty(e.prototype,"computedRadius",{get:function(){return this.radius-this.borderWidth/2},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"strokeProgress",{get:function(){return 2*Math.PI*this.computedRadius*this.value/this.goal+" "+2*Math.PI*this.computedRadius},enumerable:!0,configurable:!0}),Object.defineProperty(e.prototype,"strokeEmptyProgress",{get:function(){return"0 "+2*Math.PI*this.computedRadius},enumerable:!0,configurable:!0}),e}(),o=function(e){void 0===e&&(e={}),this.color=e.color,this.text=e.text,this.x=e.x||0,this.y=e.y||0,this.fontSize=e.fontSize||"1em"},s=function(){function e(){this.bgRadius=100,this.rounded=!0,this.reverse=!1,this.animationSecs=.5,this.segmentsLoaded=!1,this.isIE11=/Trident.*rv[ :]*11\./.test(navigator.userAgent)}return Object.defineProperty(e.prototype,"segments",{set:function(e){var t=this;this.segmentsLoaded=!1,this.sortedSegments=this.sortSegments(e),setTimeout(function(){return t.segmentsLoaded=!0},0)},enumerable:!0,configurable:!0}),e.prototype.ngOnInit=function(){},e.prototype.sortSegments=function(e){var n=this;return e&&e.sort(function(e,t){return n.reverse?e.value/e.goal>t.value/t.goal?1:-1:e.value/e.goal>t.value/t.goal?-1:1})},e.decorators=[{type:t.Component,args:[{selector:"ng-gauge",template:'<svg viewBox="0 0 200 200">\n  <g\n    class=kw-holder\n    [attr.transform]="isIE11 ? \'translate(100 100) rotate(-90)\' : \'\'">\n    <circle\n      class=kw-back\n      [attr.r]="bgRadius"\n      [style.fill]=bgColor/>\n\n      <g\n        *ngFor="let segment of sortedSegments">\n        <circle\n          class=kw-mid\n          [style.stroke]=segment.bgColor\n          [style.strokeWidth]=segment.borderWidth\n          [attr.r]=segment.computedRadius/>\n\n          <circle\n            class=kw-front\n\n            [style.transition]="\'stroke-dasharray \' + animationSecs + \'s\'"\n            [style.stroke]=segment.color\n            [style.strokeWidth]=segment.borderWidth\n            [style.strokeDasharray]="segmentsLoaded ? segment.strokeProgress : segment.strokeEmptyProgress"\n            [style.strokeLinecap]="rounded ? \'round\' : \'\'"\n            [attr.r]=segment.computedRadius/>\n      </g>\n  </g>\n\n  <g\n    transform="translate(100, 100)">\n    <text\n      class=kw-label\n      *ngFor="let label of labels"\n      [attr.x]=label.x\n      [attr.y]=label.y\n      [style.fill]=label.color\n      [style.fontSize]=label.fontSize\n      text-anchor=middle>\n      {{label.text}}\n    </text>\n  </g>\n</svg>\n',styles:[".kw-front,.kw-mid{fill:transparent}.kw-holder{-webkit-transform:translate(100px,100px) rotate(-90deg);transform:translate(100px,100px) rotate(-90deg)}"]}]}],e.ctorParameters=function(){return[]},e.propDecorators={bgRadius:[{type:t.Input}],bgColor:[{type:t.Input}],rounded:[{type:t.Input}],reverse:[{type:t.Input}],animationSecs:[{type:t.Input}],labels:[{type:t.Input}],segments:[{type:t.Input}]},e}(),a=function(){function e(){}return e.decorators=[{type:t.NgModule,args:[{imports:[n.CommonModule],bootstrap:[s],declarations:[s],exports:[s]}]}],e}();e.GaugeSegment=r,e.GaugeLabel=o,e.GaugeComponent=s,e.GaugeModule=a,Object.defineProperty(e,"__esModule",{value:!0})});
//# sourceMappingURL=gauge.umd.min.js.map